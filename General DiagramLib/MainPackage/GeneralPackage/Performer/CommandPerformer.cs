//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан инструментальным средством
//     В случае повторного создания кода изменения, внесенные в этот файл, будут потеряны.
// </auto-generated>
//------------------------------------------------------------------------------
namespace GeneralPackage.Performer
{
	using GeneralPackage.GameData;
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
    using GeneralPackage.Structures;

	public class CommandPerformer
    {
        #region attributes

        private readonly Board board;

        #endregion

        #region step-by-step model

        private enum actions { move, grab };
        private static readonly int actionsCount = 2;
        private bool[] completedActions = new bool[actionsCount];
        
        public void newTurn()
        {
            Array.Clear(completedActions, 0, actionsCount);
        }



        #endregion

        #region constructor

        public CommandPerformer(Board board)
        {
            this.board = board;
        }

        #endregion

        private bool isPathLegal(Coord start, Coord destination, int agentID) //отладить
        {
            Coord temp = new Coord();
            return !board.Walls.intersectsWalls(start, destination, out temp); //does not intersect walls
        }

    #region Agent functions

      #region IWalker

        public bool makeStep(Coord direction, double speedPercent, int agentID) //отладить
        {
            if (completedActions[(int)actions.move])
            {
                return false;
            }
            else
            {
                completedActions[(int)actions.move] = true;
            }

            double norm = direction.norm();
            double speed = board.Agents.getDictionary()[agentID].speed;
            double sp = Math.Min(speedPercent, 1);
            Coord dir = new Coord { x = direction.x / norm, y = direction.y / norm };

            if (sp <= 0) {
                return false;
            }
            Coord movementVector = new Coord(dir.x * sp * speed, 
                                       dir.y * sp * speed);
            if (isPathLegal(board.Agents[agentID].coord, board.Agents[agentID].coord + movementVector, agentID))
            {
                Coord temp = board.Agents[agentID].coord + movementVector;
                if (!temp.inField()) {
                    return false;
                }
                board.Agents[agentID].coord = temp;
                //System.Console.WriteLine("makeStep/3 : direction = {0}, speedPerc = {1}. Movement vector = {2}",
               //TODO                                        direction, speedPercent, movementVector);
                return true;
            }
            else
            {
                return false;
            }
        }

        public bool makeStep(Coord direction,int agentID)
        {
            double speed = board.Agents.getDictionary()[agentID].speed;
            double norm = direction.norm();
            if (norm > speed)
            {
                return makeStep(direction, 1.0, agentID);
            }
            else
            {
                if (Math.Abs(direction.x) <= double.Epsilon && Math.Abs(direction.y) <= double.Epsilon)
                {//проверка на нулевой вектор
                    return true;
                    
                }
                double k = norm / speed;
                //System.Console.WriteLine("makeStep/2 : direction = {0}, k = {1}, speed = {2}, norm = {3}",
                //                                       direction, k, speed, norm);
                return makeStep(direction, k, agentID);
            }
        }

      #endregion

      #region ISensor

        public AgentCutaway[] agentsAround(int agentID)
        {
            List<AgentCutaway> list = new List<AgentCutaway>();
            IReadOnlyDictionary<int,Agent> dict = board.Agents.getDictionary();
            Coord c =  dict[agentID].coord;
            double rad = dict[agentID].viewRadius;
            foreach (Agent ag in dict.Values)
            {
                if (ag.ID != agentID && ((c - ag.coord).norm() <= rad))
                {
                    list.Add(ag.getCutaway());
                }
            }
            return list.ToArray();
        }

        public Segment[] wallsAround(int agentID) 
        {
            List<Segment> list = new List<Segment>();
            List<Coord> sorter = new List<Coord>();
            IReadOnlyDictionary<int, Agent> dict = board.Agents.getDictionary();
            Coord c = dict[agentID].coord, beg, end;
            double R = dict[agentID].viewRadius;
            double K, C, B, X, Y;
            Segment temp = new Segment();
            foreach (Segment wall in board.Walls.getList())
            {
                beg = wall.beg - c;
                end = wall.end - c;
                if (beg.x != end.x)
                {
                    K = (beg.y - end.y) / (beg.x - end.x);
                    C = beg.y - K * beg.x;
                    B = K * K + 1;
                    if (R * R - C * C + K * K * R * R > 0)
                    {
                        X = (Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.end.x = X + c.x;
                        temp.end.y = Y + c.y;
                        X = (-Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.beg.x = X + c.x;
                        temp.beg.y = Y + c.y;

                        if (wall.beg.x < temp.beg.x && wall.end.x < temp.beg.x ||
                            wall.beg.x > temp.end.x && wall.end.x > temp.end.x)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.x.CompareTo(dot2.x));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
                else
                {
                    if (R > beg.x)
                    {
                        X = beg.x;
                        Y = Math.Sqrt(R * R - X * X);
                        temp.end = new Coord { x = X + c.x, y = Y + c.y };
                        temp.beg = new Coord { x = X + c.x, y = -Y + c.y };
                        if (wall.beg.y < temp.beg.y && wall.end.y < temp.beg.y ||
                            wall.beg.y > temp.end.y && wall.end.y > temp.end.y)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.y.CompareTo(dot2.y));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
            }
            return list.ToArray();
        }

      #endregion

      #region ISearcher

        public bool grabObject(int agentID, int objectID)
        {
            if (completedActions[(int)actions.grab])
            {
                return false;
            }
            else
            {
                completedActions[(int)actions.grab] = true;
            }
            IReadOnlyDictionary<int, Agent> dict = board.Agents.getDictionary();
            if (dict.ContainsKey(objectID) && dict.ContainsKey(agentID) &&
                    (dict[agentID].coord - dict[objectID].coord).norm() < dict[agentID].viewRadius &&
                    isPathLegal(dict[agentID].coord, dict[objectID].coord, agentID))
            {
                board.Agents.setAgentState(objectID, AgentState.FoundTarget);
                return true;
            }
            return false;
        }

        public Coord agentPosition(int agentID)
        {
            return board.Agents.getDictionary()[agentID].coord;
        }

      #endregion


    #endregion


    }
}

