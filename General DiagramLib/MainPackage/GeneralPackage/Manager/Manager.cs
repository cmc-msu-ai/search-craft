//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан инструментальным средством
//     В случае повторного создания кода изменения, внесенные в этот файл, будут потеряны.
// </auto-generated>
//------------------------------------------------------------------------------
namespace GeneralPackage.Manager
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
    using GameData;
    using Controller;
    using Structures;
    using Performer;
    using Visualizer;


	public class Manager
    {

        #region attributes

        public Board board
		{
			get;
			set;
        }   //TODO: switch public to private

        private CommandPerformer performer{
            get;
            set;
        }

        private Visualizer vizualizer
        {
            get;
            set;
        }

        #endregion

        #region constructor

        public Manager()
        {
            board = new Board();
            performer = new CommandPerformer(board);
            board.Agents.setPerformer(performer);
        }
        


        #endregion

        #region adding agents


        public Tuple<ControllerSet, int> addAgent(Coord startCoord, AgentBaseClass eventHandler,
                                    double speed, double viewRadius, string interfaceKey,
                                    AgentType type  = AgentType.CommonSearcher, AgentState state = AgentState.Common)
        {// interfaceKey - строка, s - ISensor, f - ISearcher, w - IWalker
            int ID;
            ID = board.Agents.addCustomAgent(startCoord, eventHandler, speed, viewRadius, type, state);
            AgentController cntrl = new AgentController(performer, ID);
            ControllerSet cntrlSet = new ControllerSet();
            if (interfaceKey.Contains('s')){
                cntrlSet.iSensor = cntrl;
            }
            if (interfaceKey.Contains('w')){
                cntrlSet.iWalker = cntrl;
            }
            if (interfaceKey.Contains('f')){
                cntrlSet.iSearcher = cntrl;
            }
            return new Tuple<ControllerSet,int>(cntrlSet,ID);
        }

        
        //public int addSimpleTarget()
        //{
        //    int ID;
        //    Coord startCoord = Coord.rand();
        //    ID = board.Agents.addCustomAgent(startCoord, new AgentBaseClass()
        //        , 0.0, 0.00000001, AgentType.SearchTarget, AgentState.Target);
        //    AgentController cntrl = new AgentController(performer, ID);
        //    return ID;
        //}

        //public int addSimpleTarget(Coord startCoord)
        //{
        //    int ID;
        //    ID = board.Agents.addCustomAgent(startCoord, new AgentBaseClass(), 0.0, 0.00000001, AgentType.SearchTarget, AgentState.Target);
        //    AgentController cntrl = new AgentController(performer, ID);
        //    return ID;
        //}


        //public void addTestAgent()
        //{
        //    board.Agents.addTestAgent();
        //}

        

        public void delAgent(int id)
        {
            board.Agents.delAgent(id);
        }
            

        #endregion

        #region vizualization

        public CommonFormVisualizer getFormVis(System.Windows.Forms.PictureBox screen)
        {
            return new CommonFormVisualizer(board, screen);
        }

        #endregion

        #region action-cycle

        public void launchAgents()
        {
            //allows each agent to do one action
            board.Agents.launchAgents();
        }

        #endregion

        #region agent states

        public AgentState getAgentState(int id)
        {
            return board.Agents.getDictionary()[id].state;
        }

        #endregion

        #region отладка
        /*
        public Segment[] wallsAround(int agentID) //Отладить и удалить TODO:
        {
            List<Segment> list = new List<Segment>();
            List<Coord> sorter = new List<Coord>();
            IReadOnlyDictionary<int, Agent> dict = board.Agents.getDictionary();
            Coord c = dict[agentID].coord, beg, end;
            double R = dict[agentID].viewRadius;
            double K, C, B, X, Y;
            Segment temp = new Segment();
            foreach (Segment wall in board.Walls.getList())
            {
                beg = wall.beg - c;
                end = wall.end - c;
                if (beg.x != end.x)
                {
                    K = (beg.y - end.y) / (beg.x - end.x);
                    C = beg.y - K * beg.x;
                    B = K * K + 1;
                    if (R * R - C * C + K * K * R * R > 0)
                    {
                        X = (Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.end.x = X + c.x;
                        temp.end.y = Y + c.y;
                        X = (-Math.Sqrt(-C * C + K * K * R * R + R * R) - K * C) / B;
                        Y = K * X + C;
                        temp.beg.x = X + c.x;
                        temp.beg.y = Y + c.y;

                        if (wall.beg.x < temp.beg.x && wall.end.x < temp.beg.x ||
                            wall.beg.x > temp.end.x && wall.end.x > temp.end.x)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.x.CompareTo(dot2.x));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
                else
                {
                    if (R > beg.x)
                    {
                        X = beg.x;
                        Y = Math.Sqrt(R * R - X * X);
                        temp.end = new Coord { x = X + c.x, y = Y + c.y };
                        temp.beg = new Coord { x = X + c.x, y = -Y + c.y };
                        if (wall.beg.y < temp.beg.y && wall.end.y < temp.beg.y ||
                            wall.beg.y > temp.end.y && wall.end.y > temp.end.y)
                        {

                        }
                        else
                        {
                            sorter.Clear();
                            sorter.Add(wall.beg);
                            sorter.Add(wall.end);
                            sorter.Add(temp.beg);
                            sorter.Add(temp.end);
                            sorter.Sort((dot1, dot2) => dot1.y.CompareTo(dot2.y));
                            list.Add(new Segment(sorter[1], sorter[2]));
                        }
                    }
                }
            }
            return list.ToArray();
        }
        */
        #endregion

    }
}

